---
title: "counts_analysis"
author: "Mary T. Yohannes"
date: "7/13/2020"
output: word_document
---

# 1) Import needed libraries 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#BiocManager::install("") #used to install bioconductor packages 
library(tximport) #imports transcript-level abundance, estimated counts and transcript lengths, and summarizes into matrices for use with downstream gene-level analysis packages
library(dplyr)
library(ggplot2)
#library(ggthemes)
library(limma)
library(Glimma)
library(edgeR)
library(variancePartition)
library(BiocParallel)
library(stringr)
library(RColorBrewer) 
```

# ############################## Info on the samples #########################################
## Obtained from "Sex, scavengers and chaperones" paper by Levin et al -- looks at different natural populations of symbiodiniaceae
## 2 populations (South Molle (SM) = sensitive, Magnetic Island (MI) = tolerant) -> 6 samples each -> 4 replicates = 24 samples each -> two temperatutres (27 and 32C) -- day 1 doesn't have 32C -> three time points (days 1, 9, 13) -- day 1 are baseline control groups 
## #######################################################################


## 2) Import samples' info
```{r}
# originally downloaded from ncbi web from Run Selector (edited metadata with only the columns we are interested in)
samples <- read.table("/projectnb/incrna/mary_lncrna/R/samples.txt", header = TRUE, sep=",", stringsAsFactors = F)
colnames(samples)[1:5] <- c("sample_id","population","time_point","temp","tolerance") #rename columns 
samples$time_point <- gsub("-1", "1", samples$time_point) # substituted "day -1" with "day 1" in the time_point column


#g <- samples[c(1,4,3,2)] #another dataframe without the tolerance column
```

# Run on the command line/terminal (only need to run once) - unzipped the count files and placed them in another directory 
# for f in *.gz ; do gunzip -c "$f" > /projectnb/incrna/mary_lncrna/R/repeat/"${f%.*}" ; done


## 3a) Accessing the salmon output files and reading them in as matrices of their abundance, counts, and length 
```{r}
# setting up the names for the files (that were just unzipped) to be imported/read
file_names <- paste(samples$sample_id, "_1.transcripts_quant.quant.sf", sep = "")

# run tximport - results in abundance, counts, and length matrices (this basically goes through each count file for each sample, take the columns: EffectiveLength, TPM, NumReads, and put them in separate matrices with samples as columns and genes as rows)
txi <- tximport(file_names, type="salmon", txOut=TRUE, countsFromAbundance="lengthScaledTPM") 

# create a DGEList object from the "counts" matrix   
cts <- DGEList(txi$counts)
#cts$counts

#dgeObj$counts = cts$counts

# rename the column names using the "sample_id" column in the "samples" file that was imported at the beginning
colnames(cts) <- samples$sample_id 
```

# 4) Edit the "samples" element in the DGEList-object to count for the different conditions of the experiment (according to the samples tables imported earlier)
```{r}
# update "group" column to categorize the samples into the two populations 
cts$samples$group <- as.character(cts$samples$group) # had to convert the column into a character type in order to replace it  
cts$samples$group[colnames(cts) %in% samples$sample_id] <- str_sub(samples$population, -3, -2) # update 
cts$samples$group <- as.factor(cts$samples$group) # convert back to a factor 

# add a column to separate samples into three time points 
cts$samples$day <- as.factor(str_sub(samples$time_point, -2,-1))

# add a column to separate samples into two temperatures  
cts$samples$temp <- as.factor(samples$temp)

# variables used in step 6 - needed to be run prior to filtering the data
pre_lcpm <- cpm(cts, log=TRUE) # this line should be run before step 5 so that the dgeObj used is unfiltered 

# Before filtering, the average library size of our dataset was about 3.8 million, so L approx. 3.76 and the minimum log-CPM value for each sample becomes log2(2/3.76) = -0.91; a count of zero for this data maps to a log-CPM value of -0.91 after adding the prior count or offset
L <- mean(cts$samples$lib.size) * 1e-6
M <- median(cts$samples$lib.size) * 1e-6
#c(L, M) # 3.758108 3.837114
```

# ################################################################################
# In the website that I followed the procedures from had a section on Organising gene annotations which I have not done and maybe I will come back to 
# ################################################################################

# 5) Removing genes that are lowly expressed
```{r}
table(rowSums(cts$counts==0)==48) # 1.4% of genes in the dataset have zero counts across all 48 samples

# filterByExpr (function in the edgeR package) filter out genes while keeping the ones with worthwhile counts

dim(cts) # 48155 genes 
keep <- filterByExpr(cts, group=cts$samples$group)
cts <- cts[keep,, keep.lib.sizes=FALSE]
dim(cts) # 32095 genes - about 2/3 (67%) of the number that we started with
```

# 6) Plot: density of log-CPM values of each sample for raw pre-filtered data and post-filtered data 
```{r}
# code taken from the online tutorial 
lcpm.cutoff <- log2(10/M + 2/L) # log-CPM threshold used in the filtering step (dotted vertical lines in the graphs)
col <- brewer.pal(12, "Paired")
par(mfrow=c(1,2))
plot(density(pre_lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.26), las=2, main="", xlab="")
title(main="A. Raw data", xlab="Log-cpm")
abline(v=lcpm.cutoff, lty=3)
for (i in 2:ncol(cts)){
den <- density(pre_lcpm[,i])
lines(den$x, den$y, col=col[i], lwd=2)
}
# legend("topright", samples$sample_id, text.col=col, bty="n", ncol = 2, cex = 0.5)
lcpm <- cpm(cts, log=TRUE)
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.26), las=2, main="", xlab="")
title(main="B. Filtered data", xlab="Log-cpm")
abline(v=lcpm.cutoff, lty=3)
for (i in 2:ncol(cts)){
den <- density(lcpm[,i])
lines(den$x, den$y, col=col[i], lwd=2)
}
# legend("topright", samples$sample_id, text.col=col, bty="n", ncol = 2, cex = 0.5)
```

# 7) Normalising gene expression distributions by the method of trimmed mean of M-values (TMM) (using calcNormFactors function in edgeR)
```{r}
# before 
lcpm <- cpm(cts, log=TRUE)
boxplot(lcpm, las=2, col=col, main="")
title(main="Normalised data",ylab="Log-cpm")

# normalisation factors = scaling factors for the library sizes
cts <- calcNormFactors(cts, method = "TMM")
cts$samples$norm.factors
# for our dataset, the effect of TMM-normalisation is mild - the scaling factors are all relatively close to 1

# # after - very slight diff 
lcpm <- cpm(cts, log=TRUE)
boxplot(lcpm, las=2, col=col, main="")
title(main="Normalised data",ylab="Log-cpm")
```

# 10-a) Pearson correlation between mrna vs lncrna - produce a table with gene IDs, corr values, and p-value --- code was written in a script and submitted as a job on the cluster (took about 8hr and 30sec to run)
```{r}
# colnames(cts)
gene_id <- data.frame(rownames(cts)) # list of genes 
lncRNA <- filter(gene_id, !grepl("mRNA",rownames.cts.)) # filter the gene ids that don't have "mRNA" in them -- 7,897
mRNA <- filter(gene_id, grepl("mRNA",rownames.cts.)) # filter the gene ids that have "mRNA" in them -- 24,198

# remove the ".1" at the end of the gene ids and convert to a string of characters 
gene_id1 <- sub('^([^.]+.[^.]+).*', '\\1', lncRNA$rownames.cts.) 
gene_id2 <- sub('^([^.]+.[^.]+.[^.]+).*', '\\1', mRNA$rownames.cts.) 
gene_id <- c(gene_id1,gene_id2) # combine the above gene ids: one large character with lncrnas first and mrnas following 

# separate count data into two: lncrna and mrna 
lds <- subset(cts$counts, rownames(cts) %in% lncRNA$rownames.cts.) # lncrna expression matrix
mds <- subset(cts$counts, rownames(cts) %in% mRNA$rownames.cts.) # mrna expression matrix 

#x <- lds
#y <- mds

# test run  
x <- lds[1:1000,]
y <- mds[1:1000,]

# columns for matrix 
p_value <- list(); corr_coef <- list(); gene1 <- list(); gene2 <- list()

for (i in 1:nrow(x)) {
  for (j in 1:nrow(y)){
    c <- cor.test(x[i,], y[j,], method = "pearson") 
    # filter out the values based on the cutoff values: corr coef >= |0.95| and a P-value < 0.05
    if (abs(c$estimate) >= 0.95 & c$p.value < 0.05) {
      gene1 <- c(gene1,rownames(x)[i]) # get name of first gene 
      gene2 <- c(gene2,rownames(y)[j]) # get name of second gene 
      p_value <- c(p_value,c$p.value) # get p-value 
      corr_coef <- c(corr_coef,c$estimate) # get correlation coefficient 
    }
  }}
ds <- cbind(gene1,gene2,corr_coef,p_value)
ds <- as.data.frame(ds) # convert to data frame
#ds <- apply(ds,2,as.character) # convert elements into character type
#write.csv(ds, "corr_result_1hr.csv") # write it into a table 

ds

## are the interactions that we get consistent across samples? 
```

# once I made sure the output was how I wanted it to be, I created an Rscript (corr_test.R) and submitted it as a job. I had to download the lncRNA (lds) and mRNA (mds) files to the terminal before I could run the job. The .qsub file is called "corr_test.qsub and can be found in the "repeat" directory (same as this document). It has all the bash options and the command to load the R module. The .R file does not have the bash options. Once the .cvs file from that script is produced, I imported it onto here and did further analysis. 



# 10-b) Correlation heatmap 
```{r}
# read in the corr test output  
corr_result <- read.table("/projectnb/incrna/mary_lncrna/R/repeat/output.csv", header = TRUE, sep="", stringsAsFactors = F)

#dim(corr_result) -- # 1345 interactions 
#summary(corr_result)

# edit column names to show which ones are mrna and lncrna 
colnames(corr_result)[1:2] <- c("lncRNA", "mRNA")

# checking that mrna and lncrna columns are labeled correctly 
#sapply(colnames(corr_result[]), function(x) grep("mRNA", corr_result[,x]))

#length(unique(corr_result$lncRNA)) # 119 lncrnas were involved in the interaction 
#length(unique(corr_result$mRNA)) # 670 mrnas were involved in the interaction 

  
# converting the data frame into a correlation matrix 
corr1 <- corr_result[1:3] # another data frame without p-value 
# create a symmetrical dataframe same as corr1 but with columns inverted for lncRNA and mRNA
tmp <- data.frame(lncRNA = corr1$mRNA, mRNA = corr1$lncRNA, corr_coef = corr1$corr_coef)
tmp2 <- rbind(corr1,tmp)
# get a correlation matrix and set diagonal to 1
corr_matrix <- as.data.frame.matrix(xtabs(corr_coef ~ ., tmp2))
diag(corr_matrix) <- NA # set diagonal to NA


# heatmap 5 interactions 
ggplot(data = corr1[1:5,], aes(x=lncRNA, y=mRNA, fill=corr_coef)) + 
  geom_tile() + 
  geom_text(aes(lncRNA, mRNA, label = corr_coef), color = "white", size = 3)+
  theme(axis.ticks.x = element_blank(),
        axis.text.x = element_blank())+
    #scale_fill_viridis_c()+
  scale_fill_gradient2(low="blue", high="red", #colors in the scale
              midpoint=mean(0.9500036, 0.9757489),    #same midpoint for plots (mean of the range)
               #breaks=seq(0.9,1,0.95), #breaks in the scale bar
               limits=c(0.9500036, 0.9757489))
  
# heatmap for whole data  
ggplot(data = corr1, aes(x=lncRNA, y=mRNA, fill=corr_coef)) + 
  geom_tile() + 
  theme(axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank())+
  scale_fill_gradient2(mid = "blue", high="red", #colors in the scale
              midpoint=mean(0.9500036, 0.9757489),    #same midpoint for plots (mean of the range)
               #breaks=seq(0.9,1,0.95), #breaks in the scale bar
               limits=c(0.9500036, 0.9757489))
  
  
  
  
#scale_fill_viridis_c()
#geom_text(aes(lncRNA, mRNA, label = corr_coef), color = "white", size = 3)

# Heatmap 2 

t <- corr_matrix
t[t == 0] <- NA
library(gplots)
heatmap.2(as.matrix(t), col=c("red", "green","purple","blue"), Rowv=F, Colv=F, dendrogram="none", scale="none", trace="none")


# Get lower triangle of the correlation matrix
  get_lower_tri<-function(corr_matrix){
    corr_matrix[upper.tri(corr_matrix)] <- NA
    return(corr_matrix)
  }
# Get upper triangle of the correlation matrix
  get_upper_tri <- function(corr_matrix){
    corr_matrix[lower.tri(corr_matrix)]<- NA
    return(corr_matrix)
  }

upper_tri <- get_upper_tri(corr_matrix)
heatmap.2(as.matrix(upper_tri), Rowv=F, Colv=F, dendrogram="none", scale="none", trace="none")

table(corr1$lncRNA)


# subsetting the data to only include lncrna's with >100 frequency/interactions 
subs_l <- corr1 %>% group_by(lncRNA) %>% filter(n()>0)
length(table(subs_l$lncRNA))

subs <- subs_l %>% group_by(mRNA) %>% filter(n()>5)
table(subs$lncRNA)


# heatmap for subset data  
ggplot(data = subs, aes(x=lncRNA, y=mRNA, fill=corr_coef)) + 
  geom_tile() + 
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank())+
  scale_fill_viridis_c()
  
  # scale_fill_gradient2(low = "yellow", mid = "blue", high="red", #colors in the scale
  #             midpoint=mean(0.9500036, 0.9757489),    #same midpoint for plots (mean of the range)
  #              #breaks=seq(0.9,1,0.95), #breaks in the scale bar
  #              limits=c(0.9500036, 0.9757489))


```


# 8) Unsupervised clustering of samples
```{r}
# see similarities and dissimilarities between samples in an unsupervised manner so that we can have an idea of the extent to which differential expression can be detected before carrying out formal tests

# first dimension = the leading-fold-change that best separates samples and explains the largest proportion of variation in the data
# subsequent dimensions = have a smaller effect and are orthogonal to the ones before it


# samples seem to cluster well within population and temperature groups over dimension 1 and 2 - mostly similar 
lcpm <- cpm(cts, log=TRUE)
par(mfrow=c(1,2))
col.group <- cts$samples$group
levels(col.group) <-  brewer.pal(nlevels(col.group), "Set1")
col.group <- as.character(col.group)
plotMDS(lcpm, labels=cts$samples$group, col=col.group)
title(main="A. Population")

col.temp <- cts$samples$temp
levels(col.temp) <-  brewer.pal(nlevels(col.temp), "Set2")
col.temp <- as.character(col.temp)
plotMDS(lcpm, labels=cts$samples$temp, col=col.temp)
title(main="B. Temperature")

# day has no effect on expression differences -- no cluster -- left out of downstream anaysis 
# col.day <- cts$samples$day
# levels(col.day) <-  brewer.pal(nlevels(col.day), "Set3")
# col.day <- as.character(col.day)
# plotMDS(lcpm, labels=cts$samples$day, col=col.day)
# title(main="B. Time Point (day)")

#### Glimma #####
# Tried glimma but it didn't work; it runs but there is no plots and I am not sure why? 
#glMDSPlot(lcpm, labels=paste(dgeObj$samples$group, dgeObj$samples$day, dgeObj$samples$temp, sep="_"), groups=dgeObj$samples[,c(2,5,6)], launch=FALSE)


# James method 
g <- interaction(cts$samples$group, cts$samples$day, cts$samples$temp)
design <- model.matrix(~0+g) # read more on this
colnames(design) <- levels(g) 

# the plots from the following two commands produce are exactly the same - limma recomputes its own log-CPM values internally with a smaller prior count

# plot mRNA and lncRNA separately, actually do after normalization like in deseq
plotMDS(cts, labels=g, cex=0.75, xlim=c(-4, 5)) # not corrected dgeObj

# combined all three groups from your method above 
plotMDS(lcpm, labels=paste(cts$samples$group, cts$samples$day, cts$samples$temp, sep="."), cex=0.75, xlim=c(-4, 5))


#plotMDS(lcpm, labels = NULL, col = as.numeric(cts$samples$group), pch = as.numeric(cts$samples$temp), cex = 2)


## clustering:look at MDS plot for mrnas and lncrna 
# plotMDS for lncrna and mrna by themselves separately 
```

# ######################## Needs in-depth review ###########################

# 9) Differential expression analysis
```{r}
# creating a design matrix

g <- dgeObj$samples$group
d <- dgeObj$samples$day ## can ignore for now 
t <- dgeObj$samples$temp

design2 <- model.matrix(~0+g+d+t)
colnames(design2)[3] <- "d9"
colnames(design2) <- gsub("g", "", colnames(design2))
design2

# contrasts
contr.matrix <- makeContrasts(
   MIvsSM = MI-SM, 
   levels = colnames(design2))
contr.matrix

# removing heteroscedascity from count data
par(mfrow=c(1,2))
v <- voom(dgeObj, design2, plot=TRUE)
v

vfit <- lmFit(v, design2)
vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
efit <- eBayes(vfit)
plotSA(efit, main="Final model: Mean-variance trend")


# examining the number of DE genes
summary(decideTests(efit))

tfit <- treat(vfit, lfc=1)
dt <- decideTests(tfit)
summary(dt)

de.common <- which(dt[,1]!=0)
length(de.common)

# head(tfit$genes$SYMBOL[de.common], n=20) - this step might work if you map gene symbols to the gene IDs using different libs  

vennDiagram(dt[,1], circle.col=c("turquoise", "salmon"))


# examining individual DE genes from top to bottom
MIvsSM <- topTreat(tfit, coef=1, n=Inf)
dim(MIvsSM)

# useful graphical representations of differential expression results
plotMD(tfit, column=1, status=dt[,1], main=colnames(tfit)[1], xlim=c(-8,13))


# heatmap 
library(gplots)

mycol <- colorpanel(1000,"blue","white","red")
heatmap.2(lcpm[1:100,], scale="row", labCol=g, 
   col=mycol, trace="none", density.info="none", 
   margin=c(8,6), lhei=c(2,10), dendrogram="column")

```
